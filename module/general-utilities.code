log() {
    # Ensure log file exists
    if [ ! -f "$LOGFILE" ]; then
        touch "$LOGFILE"
    fi

    # Write log
    echo -e "${LIGHTER_YELLOW}$(date +"%Y-%m-%d %H:%M:%S")${NC} ${ORANGE}$1${NC}" | tee -a "$LOGFILE"
}

# Function to check if the script is run as root
is_root() {
    if [ "$EUID" -eq 0 ]; then
        log "${CALLING_SCRIPT} ${ORANGE}This script is running as root.${NC}"
        return 0
    else
        log "${CALLING_SCRIPT} ⚠️ ${LIGHTER_YELLOW} This script is not running as root.${NC}"
        return 1
    fi
}

# Function to check if a command exists
command_exists() {
    export CALLING_SCRIPT="${CYAN}${EXE_SCRIPT_NAME%.*} [command_exists] module${ORANGE}"
    
    local cmd="$1"
    if [ -z "$cmd" ]; then
        log "${CALLING_SCRIPT} ${RED}Empty command is an error.${NC}"
        return 1
    fi
    
    # First check if command exists in PATH
    if ! command -v "$cmd" >/dev/null 2>&1; then
        # Special handling for docker-compose if not found in PATH
        if [ "$cmd" == "docker-compose" ]; then
            # Check if docker exists and if docker compose plugin works
            if command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1; then
                log "${CALLING_SCRIPT} ${GREEN}Command ${YELLOW}[docker compose]${GREEN} exists (plugin).${NC}"
                return 0
            fi
        fi
        log "${CALLING_SCRIPT} ${RED}Command ${YELLOW}[$cmd]${RED} does not exist.${NC}"
        return 1
    fi
    
    # Command exists in PATH, now test if it actually works
    case "$cmd" in
        "docker")
            if docker version >/dev/null 2>&1; then
                log "${CALLING_SCRIPT} ${GREEN}Command ${YELLOW}[$cmd]${GREEN} exists and is functional.${NC}"
                return 0
            else
                log "${CALLING_SCRIPT} ${RED}Command ${YELLOW}[$cmd]${RED} exists but is not functional (check Docker Desktop Guest integration).${NC}"
                return 1
            fi
            ;;
        "docker-compose")
            if docker-compose version >/dev/null 2>&1; then
                log "${CALLING_SCRIPT} ${GREEN}Command ${YELLOW}[$cmd]${GREEN} exists and is functional.${NC}"
                return 0
            elif command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1; then
                log "${CALLING_SCRIPT} ${GREEN}Command ${YELLOW}[docker compose]${GREEN} exists and is functional (plugin).${NC}"
                return 0
            else
                log "${CALLING_SCRIPT} ${RED}Command ${YELLOW}[$cmd]${RED} exists but is not functional.${NC}"
                return 1
            fi
            ;;
        "git"|"curl"|"wget"|"jq"|"yq"|"java"|"openssl")
            # For these commands, test with --version or --help
            if $cmd --version >/dev/null 2>&1 || $cmd --help >/dev/null 2>&1; then
                log "${CALLING_SCRIPT} ${GREEN}Command ${YELLOW}[$cmd]${GREEN} exists and is functional.${NC}"
                return 0
            else
                log "${CALLING_SCRIPT} ${RED}Command ${YELLOW}[$cmd]${RED} exists but is not functional.${NC}"
                return 1
            fi
            ;;
        *)
            # For other commands, just check if they exist and can be executed
            if $cmd --version >/dev/null 2>&1 || $cmd -h >/dev/null 2>&1 || $cmd --help >/dev/null 2>&1; then
                log "${CALLING_SCRIPT} ${GREEN}Command ${YELLOW}[$cmd]${GREEN} exists and appears functional.${NC}"
                return 0
            else
                # Fallback: assume it's functional if it exists in PATH
                log "${CALLING_SCRIPT} ${GREEN}Command ${YELLOW}[$cmd]${GREEN} exists.${NC}"
                return 0
            fi
            ;;
    esac
}

# Function to print the error message and exit
error_exit() {
    export CALLING_SCRIPT="${CYAN}${EXE_SCRIPT_NAME%.*} [error_exit] module${ORANGE}"
    log "${CALLING_SCRIPT} - ${CALLING_SUBSCRIPT} ${RED}ERROR: $1${NC}"
    exit 1
}

# Function to prompt user with Y/n question
prompt_yn() {
    local prompt="$1"
    local default="$2"
    local response

    echo -e "${PURPLE}"
    while true; do
        read -p "$prompt (Y/n): [default $default] " response
        response=${response:-${default}}

        # Normalize to lowercase to simplify case handling
        case "${response,,}" in
            y) return 0 ;;   # Yes
            n) return 1 ;;   # No
            *) echo -e "${RED}Please answer yes or no.${NC}" ;;  # Invalid input
        esac
    done
    echo -e "${NC}"
}

# Function to loop valid input - possible choices are [file | text | number].
prompt_while_valid_input() {
    local mode="$1"             # file | text | number
    local prompt="$2"
    local default="$3"
    local expected="$4"         # filename, description, or max number
    local result_var="$5"
    local regex="${6:-}"        # optional regex
    local input_value

    echo -e "${PURPLE}"
    while true; do
        case "$mode" in
            file)
                read -p "$prompt [default $default] " input_value
                input_value=${input_value:-"$default"}

                if [[ -f "$input_value" ]]; then
                    checksum=$(sha256sum "$input_value" | awk '{print $1}')
                    log "${CALLING_SCRIPT} SHA-256 checksum of [$expected]: [$checksum]"
                fi

                if [[ "$(basename "$input_value")" = "$expected" && -f "$input_value" ]]; then
                    if [[ -n "$regex" && ! "$input_value" =~ $regex ]]; then
                        echo -e "${RED}Input does not match required pattern. Try again.${PURPLE}"
                        continue
                    fi
                    log "${CALLING_SCRIPT} File exists: [$input_value]"
                    eval $result_var="'$input_value'"
                    break
                else
                    echo -e "${RED}Invalid file. Expected [$expected]. Try again.${PURPLE}"
                fi
                ;;
            text)
                read -p "$prompt [e.g $default] " input_value

                if [[ -n "$regex" && ! "$input_value" =~ $regex ]]; then
                    echo -e "${RED}Input does not match required pattern. Try again.${PURPLE}"
                    continue
                fi

                validate_and_create_file "$expected"
                if [[ -n "$expected" && "$expected" = *.* ]]; then
                    echo "$input_value" >> "${expected}"
                    log "${CALLING_SCRIPT} Saved input to: [${expected}]"
                fi

                if [[ -n "$input_value" ]]; then
                    eval $result_var="'$input_value'"
                    break
                else
                    echo -e "${RED}Input cannot be empty. Try again.${PURPLE}"
                fi
                ;;
            number)
                read -p "$prompt [1-$expected, default $default] " input_value
                input_value=${input_value:-$default}

                if [[ "$input_value" =~ ^[0-9]+$ ]] && (( input_value >= 1 && input_value <= expected )); then
                    if [[ -n "$regex" && ! "$input_value" =~ $regex ]]; then
                        echo -e "${RED}Input does not match required pattern. Try again.${PURPLE}"
                        continue
                    fi
                    eval $result_var="'$input_value'"
                    break
                else
                    echo -e "${RED}Invalid selection. Try again.${PURPLE}"
                fi
                ;;
        esac
    done

    # Export the variable dynamically to IDOL environment variable
    update_file_row "$IDOL_ENV" "export ${result_var}" "${input_value}" "=" "$SILENT_MODE" "$SILENT_MODE"
}

# Function to Verify whether the parameter that was supplied is a valid file name format.
validate_and_create_file() {
    local filepath="$1"
    local filename

    # Extract basename
    filename=$(basename "$filepath")

    # Require a dot extension
    if [[ "$filename" != *.* ]]; then
        log "${CALLING_SCRIPT} Skipped file without extension: [$filepath]"
        return
    fi

    # Validate filename: letters, numbers, underscore, dash, dot
    if [[ "$filename" =~ ^[A-Za-z0-9._-]+$ ]]; then
        # Ensure parent directory exists
        mkdir -p "$(dirname "$filepath")"

        # Create file if it does not exist
        if [[ ! -f "$filepath" ]]; then
            touch "$filepath"
            log "${CALLING_SCRIPT} Created file: [$filepath]"
        else
            log "${CALLING_SCRIPT} File already exists: [$filepath]"
        fi
    else
        log "${CALLING_SCRIPT} Skipped invalid filename: [$filepath]"
    fi
}

# Function to write data to file
write_to_file() {
    local file_path="$1"
    local data="$2"

    if [ -z "$file_path" ] || [ -z "$data" ]; then
        echo "Usage: write_to_file <file_path> <data>"
        return 1
    fi
    
    echo "$data" > "$file_path"
    return $?
}

# Function to update/add an exported parameter in a file with sorting
# Usage: update_file_row <file_path> <parameter> [value] [separator] [enable_trace] [create_backup]
# Parameters:
#   file_path: Path to the target file
#   parameter: Variable name (without "export")
#   value: Value to set (optional, if not provided, only "export VAR" will be added)
#   separator: Separator between parameter and value (default: "=")
#   enable_trace: Enable tracing messages (true/false, default: true)
#   create_backup: Create backup file (true/false, default: true)
update_file_row() {
    local file_path="$1"
    local parameter="$2"
    local value="$3"
    local separator="${4:-=}"
    local enable_trace="${5:-true}"
    local create_backup="${6:-true}"
    local temp_file backup_file new_line parameter_found=false

    # Helper functions
    trace() {
        [[ "$enable_trace" == "true" ]] && echo "$@" >&2
    }
    error() {
        echo "ERROR: $@" >&2
    }

    # Validation
    if [[ -z "$file_path" ]] || [[ -z "$parameter" ]]; then
        error "File path and parameter are required"
        return 1
    fi
    if [[ "$enable_trace" != "true" && "$enable_trace" != "false" ]]; then
        error "enable_trace must be 'true' or 'false'"
        return 1
    fi
    if [[ "$create_backup" != "true" && "$create_backup" != "false" ]]; then
        error "create_backup must be 'true' or 'false'"
        return 1
    fi

    # Build the new line
    if [[ -n "$value" ]]; then
        new_line="${parameter}${separator}${value}"
    else
        new_line="export ${parameter}"
    fi

    trace "INFO: Updating '$parameter' in '$file_path'"
    trace "INFO: New line: '$new_line'"

    # Ensure parent directory exists
    local parent_dir
    parent_dir="$(dirname "$file_path")"
    if [[ ! -d "$parent_dir" ]]; then
        trace "INFO: Creating directory: $parent_dir"
        mkdir -p "$parent_dir" || { error "Failed to create directory"; return 1; }
    fi

    temp_file="${file_path}.tmp.$$"

    if [[ -f "$file_path" ]]; then
        # Backup
        if [[ "$create_backup" == "true" ]]; then
            backup_file="${file_path}.backup.$(date +%Y%m%d_%H%M%S)"
            cp "$file_path" "$backup_file" || { error "Failed to create backup"; return 1; }
            trace "INFO: Backup created: $backup_file"
        fi

        # Escape separator for regex
        local sep_regex
        sep_regex=$(printf '%s' "$separator" | sed -e 's/[]\/$*.^|[]/\\&/g')

        # Process lines
        local line_count=0
        while IFS= read -r line || [[ -n "$line" ]]; do
            ((line_count++))
            if [[ -z "$line" ]]; then
                continue
            fi
            # Match old variants
            if [[ "$line" =~ ^[[:space:]]*(export[[:space:]]+)?${parameter}([[:space:]]*${sep_regex}.*)?$ ]]; then
                parameter_found=true
                trace "INFO: Removed old '$parameter' at line $line_count"
                continue
            fi
            echo "$line"
        done < "$file_path" > "$temp_file"

        trace "INFO: Processed $line_count lines"
    else
        trace "INFO: File does not exist, creating new"
        touch "$temp_file"
    fi

    # Add new line
    echo "$new_line" >> "$temp_file"

    if [[ "$parameter_found" == "true" ]]; then
        trace "INFO: Replaced parameter '$parameter'"
    else
        trace "INFO: Added new parameter '$parameter'"
    fi

    # Sort and clean
    trace "INFO: Sorting file"
    if ! awk 'NF' "$temp_file" | sort > "${temp_file}.sorted"; then
        error "Failed to sort file"
        rm -f "$temp_file" "${temp_file}.sorted"
        return 1
    fi

    local file_changed=false
    if [[ -f "$file_path" ]]; then
        if ! cmp -s "${temp_file}.sorted" "$file_path"; then
            file_changed=true
        fi
    else
        file_changed=true
    fi

    mv "${temp_file}.sorted" "$file_path" || { error "Failed to update file"; rm -f "$temp_file"; return 1; }
    rm -f "$temp_file"

    if [[ "$file_changed" == "true" ]]; then
        trace "SUCCESS: File updated: $file_path"
    else
        trace "INFO: No changes in file: $file_path"
    fi

    return 0
}
